参考https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html#private-data

1、私有数据集由两部分组成：
真实私有数据 和 数据哈希

2、真实私有数据 只会在授权组织间，点对点地通过gossip协议传输。（而不是通过区块数据传输）
                只会存储在授权节组织的某些节点的私有状态数据库中。（这意味着排序服务跟真实私有数据是不见面的）
				
	由于真实私有数据是点对点在授权组织间传播的，为了支持跨组织通信，
	必须在通道中设置组织的锚点（集），并且在每个节点上配置CORE_PEER_GOSSIP_EXTERNALENDPOINT。
	
3、私有数据哈希：
   私有数据哈希就是普通的账本数据，可以被背书、排序和写入账本数据。（当然，账本数据是全网同步的）
   
4、如果在链码中引用私有数据，链码的事务流程就会有所不同：
   4.1：当客户端程序试图操作（读/写）或者生成私有数据，这些数据会存储在提案请求的一个临时字段里面。
        然后发送给授权组织（这里指的是私有数据的授权组织）的背书节点以请求背书。
   4.2：授权组织的背书节点拿到这个提案后，模拟执行这个提案，并将私有数据存储在自己的临时存放区中，然后基于私有数据策略，向其他授权组织的节点传播私有数据。
   4.3：背书节点返回背书结果给客户端程序（主要是模拟执行的读写集，包括公开数据和私有数据的哈希），私有数据将不会包含在背书结果里面返回给客户端。
   4.4：客户端收集到背书结果之后，整理成交易，发给排序节点，进而同步给所有链码相关方的所有节点记账。（此步骤与不涉及的私有数据的交易步骤没有任何差异）
        这样，所有记账节点就可以以一致的方式，在不知道真实私有数据的情况下，通过私有数据哈希去校验私有数据。
   4.5：在区块记账时，节点会根据私有数据策略验证自己是否在私有数据授权范围内。如果在授权范围内，节点将检查自己的临时存放区，看看自己有没有在背书阶段同步到私有数据。
        如果没有的话，节点将会尝试从其他授权节点上拉取私有数据。然后通过区块数据中的私有数据哈希来校验本地的临时存放的私有数据，验证后提交账本。
		然后，将私有数据从临时存放区存储到私有状态数据库中，并且写入到私有数据写入集中。最后，从临时存放区中删除私有数据。
		
5、私有数据共享模式：（没看懂！！！）
   5.1：使用公钥
   5.2：在链码中进行访问控制
   5.3：线下（指在区块链之外）共享私有数据
   5.4：与其他私有数据集共享私有数据。在背书阶段，客户端节点会将私有数据存储在临时字段里面，随交易提案一起提交给背书节点。
        这时，如果背书节点位于两个私有数据集授权范围的合集中，这个背书节点就可以从提案里面提取到私有数据，然后写到另一个私有数据集中。这样就完成了私有数据在不同的私有数据集间的共享。
		由于私有数据的哈希是全网共享的，所以共享的私有数据可以在全网（当然也包括新的授权范围内的节点）进行验证。
   5.5：利用chaincode转移私有数据。类似5.4，在链码里面利用临时字段，利用hash验证私有数据后将私有数据写到另一个私有数据集里面去，然后删除原来私有数据集键值对，从而完成转移。
   5.6：借助私有数据批准交易
   5.7：保持交易者的私密性，即只将hash写到链上，当有需要时才公布私有数据。
   
6、在key级别对私有数据进行精确控制
   6.1：key级别的交易访问控制。可以在私有数据值中包含私有数据授权列表，然后在链码中据此校验当前提交者的信息。这样就可以实现对提交者进行访问控制了。
   6.2：key级别的背书策略。可以在key级别实现对私有数据共享或者转移的背书控制，即可以指定必须经过哪些组织背书之后才能提交对特定key的私有数据的共享或者转移。具体是利用SetPrivateDataValidationParameter() chaincodeAPI来实现。
   
   
   
   